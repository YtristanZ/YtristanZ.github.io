<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGLåœºæ™¯ç»˜åˆ¶ä¸åŠ¨ç”»ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 900px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 20px;
            opacity: 0.9;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            justify-content: center;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            width: 300px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-section:last-child {
            border-bottom: none;
        }

        h2 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #ffcc00;
        }

        .shape-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 12px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }

        button.active {
            background: rgba(255, 193, 7, 0.3);
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: transparent;
            cursor: pointer;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        .slider-value {
            text-align: center;
            font-weight: bold;
            color: #ffcc00;
        }

        .canvas-container {
            flex: 1;
            min-width: 500px;
            max-width: 700px;
            position: relative;
        }

        canvas {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 100%;
            height: 500px;
            display: block;
        }

        .instructions {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            max-width: 900px;
            text-align: center;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #ffcc00;
        }

        .info-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .stats {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                align-items: center;
            }

            .control-panel {
                width: 100%;
                max-width: 500px;
            }

            .canvas-container {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>WebGLåœºæ™¯ç»˜åˆ¶ä¸åŠ¨ç”»ç³»ç»Ÿ</h1>
        <p class="subtitle">ç‚¹å‡»ç”»å¸ƒæ·»åŠ å›¾å½¢ï¼Œæ¯ç§å›¾å½¢éƒ½æœ‰ç‹¬ç‰¹çš„åŠ¨ç”»æ•ˆæœ</p>
    </header>

    <div class="container">
        <div class="control-panel">
            <div class="control-section">
                <h2>é€‰æ‹©å›¾å½¢</h2>
                <div class="shape-buttons">
                    <button id="triangle-btn" class="active">
                        <span>â–²</span> æ­£ä¸‰è§’å½¢
                    </button>
                    <button id="square-btn">
                        <span>â—¼</span> æ­£æ–¹å½¢
                    </button>
                    <button id="cube-btn">
                        <span>â¬›</span> ç«‹æ–¹ä½“
                    </button>
                    <button id="circle-btn">
                        <span>â—</span> åœ†å½¢
                    </button>
                </div>
            </div>

            <div class="control-section">
                <h2>é¢œè‰²è®¾ç½®</h2>
                <div class="color-picker-container">
                    <label for="color-picker">é€‰æ‹©é¢œè‰²:</label>
                    <input type="color" id="color-picker" value="#ff5722">
                </div>
            </div>

            <div class="control-section">
                <h2>åœ†å½¢è®¾ç½®</h2>
                <p>è¾¹æ•°: <span id="sides-value" class="slider-value">10</span></p>
                <input type="range" id="sides-slider" min="3" max="50" value="10">
            </div>

            <div class="control-section">
                <h2>åœºæ™¯æ§åˆ¶</h2>
                <button id="clear-btn" style="background: rgba(244, 67, 54, 0.7);">
                    <span>ğŸ—‘ï¸</span> æ¸…ç©ºåœºæ™¯
                </button>
            </div>

            <div class="control-section">
                <h2>åŠ¨ç”»è¯´æ˜</h2>
                <ul style="list-style-type: none; padding-left: 0;">
                    <li style="margin-bottom: 8px;">â–² æ­£ä¸‰è§’å½¢: æŒç»­ç¼©æ”¾</li>
                    <li style="margin-bottom: 8px;">â—¼ æ­£æ–¹å½¢: ç»•Zè½´æ—‹è½¬</li>
                    <li style="margin-bottom: 8px;">â¬› ç«‹æ–¹ä½“: ç»•ç‰¹å®šè½´æ—‹è½¬</li>
                    <li style="margin-bottom: 8px;">â— åœ†å½¢: éšæœºå¹³ç§»</li>
                </ul>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="gl-canvas" width="700" height="500"></canvas>
            <div class="info-panel">å½“å‰é€‰æ‹©: <span id="current-shape">æ­£ä¸‰è§’å½¢</span></div>
            <div class="stats">åœºæ™¯å¯¹è±¡: <span id="object-count">0</span></div>
        </div>
    </div>

    <div class="instructions">
        <h3>ä½¿ç”¨è¯´æ˜</h3>
        <p>1. ä»å·¦ä¾§é¢æ¿é€‰æ‹©è¦ç»˜åˆ¶çš„å›¾å½¢ç±»å‹</p>
        <p>2. ä½¿ç”¨é¢œè‰²é€‰æ‹©å™¨è®¾ç½®å›¾å½¢é¢œè‰²</p>
        <p>3. å¯¹äºåœ†å½¢ï¼Œå¯ä»¥ä½¿ç”¨æ»‘å—è°ƒæ•´è¾¹æ•°</p>
        <p>4. åœ¨ç”»å¸ƒä¸Šç‚¹å‡»é¼ æ ‡æ”¾ç½®å›¾å½¢</p>
        <p>5. ç‚¹å‡»"æ¸…ç©ºåœºæ™¯"æŒ‰é’®ç§»é™¤æ‰€æœ‰å›¾å½¢</p>
    </div>

    <!-- é¡¶ç‚¹ç€è‰²å™¨ - ä¿®å¤æ ¼å¼é—®é¢˜ -->
    <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec4 vPosition;
in vec4 vColor;
out vec4 aColor;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

void main() {
    aColor = vColor;
    gl_Position = uProjectionMatrix * uModelViewMatrix * vPosition;
}</script>

    <!-- ç‰‡æ®µç€è‰²å™¨ - ä¿®å¤æ ¼å¼é—®é¢˜ -->
    <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;
in vec4 aColor;
out vec4 fColor;

void main() {
    fColor = aColor;
}</script>

    <script>
        // å…¨å±€å˜é‡
        let canvas, gl;
        let program;
        let currentShape = 'triangle';
        let currentColor = [1.0, 0.34, 0.13, 1.0]; // é»˜è®¤æ©™è‰²
        let circleSides = 10;
        let objects = [];
        let objectCount = 0;

        // åˆå§‹åŒ–å‡½æ•°
        window.onload = function init() {
            canvas = document.getElementById("gl-canvas");
            gl = canvas.getContext("webgl2");

            if (!gl) {
                alert("WebGL 2.0 ä¸è¢«æ”¯æŒï¼");
                return;
            }

            // è®¾ç½®è§†å£å’Œæ¸…é™¤é¢œè‰²
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.enable(gl.DEPTH_TEST);

            // åˆå§‹åŒ–ç€è‰²å™¨ç¨‹åº
            program = initShaderProgram(gl,
                document.getElementById("vertex-shader").textContent,
                document.getElementById("fragment-shader").textContent
            );

            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            render();
        };

        // åˆå§‹åŒ–ç€è‰²å™¨ç¨‹åº
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('æ— æ³•åˆå§‹åŒ–ç€è‰²å™¨ç¨‹åº: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        // åŠ è½½ç€è‰²å™¨
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // ç¡®ä¿ç€è‰²å™¨ä»£ç ä»¥#versionå¼€å¤´ï¼Œæ²¡æœ‰å‰å¯¼ç©ºæ ¼
            const trimmedSource = source.trim();
            gl.shaderSource(shader, trimmedSource);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('ç¼–è¯‘ç€è‰²å™¨æ—¶å‡ºé”™: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // å›¾å½¢é€‰æ‹©æŒ‰é’®
            document.getElementById('triangle-btn').addEventListener('click', () => setCurrentShape('triangle'));
            document.getElementById('square-btn').addEventListener('click', () => setCurrentShape('square'));
            document.getElementById('cube-btn').addEventListener('click', () => setCurrentShape('cube'));
            document.getElementById('circle-btn').addEventListener('click', () => setCurrentShape('circle'));

            // é¢œè‰²é€‰æ‹©å™¨
            document.getElementById('color-picker').addEventListener('input', (e) => {
                const hex = e.target.value;
                currentColor = [
                    parseInt(hex.slice(1, 3), 16) / 255,
                    parseInt(hex.slice(3, 5), 16) / 255,
                    parseInt(hex.slice(5, 7), 16) / 255,
                    1.0
                ];
            });

            // åœ†å½¢è¾¹æ•°æ»‘å—
            const sidesSlider = document.getElementById('sides-slider');
            const sidesValue = document.getElementById('sides-value');
            sidesSlider.addEventListener('input', (e) => {
                circleSides = parseInt(e.target.value);
                sidesValue.textContent = circleSides;
            });

            // æ¸…ç©ºåœºæ™¯æŒ‰é’®
            document.getElementById('clear-btn').addEventListener('click', () => {
                objects = [];
                objectCount = 0;
                document.getElementById('object-count').textContent = objectCount;
            });

            // ç”»å¸ƒç‚¹å‡»äº‹ä»¶
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / canvas.width) * 2 - 1;
                const y = -(((e.clientY - rect.top) / canvas.height) * 2 - 1);

                addObject(currentShape, x, y);
            });
        }

        // è®¾ç½®å½“å‰å›¾å½¢ç±»å‹
        function setCurrentShape(shape) {
            currentShape = shape;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('triangle-btn').classList.remove('active');
            document.getElementById('square-btn').classList.remove('active');
            document.getElementById('cube-btn').classList.remove('active');
            document.getElementById('circle-btn').classList.remove('active');
            document.getElementById(shape + '-btn').classList.add('active');

            // æ›´æ–°ä¿¡æ¯é¢æ¿
            const shapeNames = {
                triangle: 'æ­£ä¸‰è§’å½¢',
                square: 'æ­£æ–¹å½¢',
                cube: 'ç«‹æ–¹ä½“',
                circle: 'åœ†å½¢'
            };
            document.getElementById('current-shape').textContent = shapeNames[shape];
        }

        // æ·»åŠ å¯¹è±¡åˆ°åœºæ™¯
        function addObject(type, x, y) {
            const object = {
                type: type,
                position: [x, y, 0],
                color: [...currentColor],
                scale: 1.0,
                rotation: 0,
                translation: [0, 0],
                time: 0,
                id: objectCount++
            };

            // æ ¹æ®ç±»å‹è®¾ç½®åˆå§‹çŠ¶æ€
            if (type === 'triangle') {
                object.scaleDirection = 1;
            } else if (type === 'circle') {
                object.translationSpeed = [Math.random() * 0.02 - 0.01, Math.random() * 0.02 - 0.01];
            }

            objects.push(object);
            document.getElementById('object-count').textContent = objects.length;
        }

        // æ¸²æŸ“å¾ªç¯
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.useProgram(program);

            // è·å–uniformä½ç½®
            const uModelViewMatrix = gl.getUniformLocation(program, "uModelViewMatrix");
            const uProjectionMatrix = gl.getUniformLocation(program, "uProjectionMatrix");

            // è®¾ç½®æŠ•å½±çŸ©é˜µ
            const projectionMatrix = mat4.create();
            mat4.ortho(projectionMatrix, -1, 1, -1, 1, -1, 1);
            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);

            // æ¸²æŸ“æ¯ä¸ªå¯¹è±¡
            objects.forEach(obj => {
                // æ›´æ–°å¯¹è±¡çŠ¶æ€
                updateObject(obj);

                // åˆ›å»ºæ¨¡å‹è§†å›¾çŸ©é˜µ
                const modelViewMatrix = mat4.create();

                // åº”ç”¨å˜æ¢
                mat4.translate(modelViewMatrix, modelViewMatrix, [obj.position[0], obj.position[1], obj.position[2]]);

                if (obj.type === 'square') {
                    mat4.rotateZ(modelViewMatrix, modelViewMatrix, obj.rotation);
                } else if (obj.type === 'cube') {
                    mat4.rotate(modelViewMatrix, modelViewMatrix, obj.rotation, [1, 1, 0]);
                } else if (obj.type === 'triangle') {
                    mat4.scale(modelViewMatrix, modelViewMatrix, [obj.scale, obj.scale, obj.scale]);
                } else if (obj.type === 'circle') {
                    mat4.translate(modelViewMatrix, modelViewMatrix, [obj.translation[0], obj.translation[1], 0]);
                }

                gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);

                // ç»˜åˆ¶å¯¹è±¡
                drawObject(obj);
            });

            requestAnimationFrame(render);
        }

        // æ›´æ–°å¯¹è±¡çŠ¶æ€
        function updateObject(obj) {
            obj.time += 0.016; // å‡è®¾60FPS

            switch(obj.type) {
                case 'triangle':
                    // ç¼©æ”¾åŠ¨ç”»
                    obj.scale += 0.02 * obj.scaleDirection;
                    if (obj.scale > 1.5 || obj.scale < 0.5) {
                        obj.scaleDirection *= -1;
                    }
                    break;

                case 'square':
                    // æ—‹è½¬åŠ¨ç”»
                    obj.rotation += 0.03;
                    break;

                case 'cube':
                    // æ—‹è½¬åŠ¨ç”»
                    obj.rotation += 0.02;
                    break;

                case 'circle':
                    // å¹³ç§»åŠ¨ç”»
                    obj.translation[0] += obj.translationSpeed[0];
                    obj.translation[1] += obj.translationSpeed[1];

                    // è¾¹ç•Œæ£€æŸ¥
                    if (obj.translation[0] > 0.8 || obj.translation[0] < -0.8) {
                        obj.translationSpeed[0] *= -1;
                    }
                    if (obj.translation[1] > 0.8 || obj.translation[1] < -0.8) {
                        obj.translationSpeed[1] *= -1;
                    }
                    break;
            }
        }

        // ç»˜åˆ¶å¯¹è±¡
        function drawObject(obj) {
            // åˆ›å»ºé¡¶ç‚¹å’Œé¢œè‰²ç¼“å†²åŒº
            const positionBuffer = gl.createBuffer();
            const colorBuffer = gl.createBuffer();

            // è·å–attributeä½ç½®
            const vPosition = gl.getAttribLocation(program, "vPosition");
            const vColor = gl.getAttribLocation(program, "vColor");

            let vertices, colors;

            switch(obj.type) {
                case 'triangle':
                    // æ­£ä¸‰è§’å½¢
                    vertices = new Float32Array([
                        0.0, 0.2, 0.0,
                        -0.2, -0.2, 0.0,
                        0.2, -0.2, 0.0
                    ]);
                    break;

                case 'square':
                    // æ­£æ–¹å½¢
                    vertices = new Float32Array([
                        -0.15, 0.15, 0.0,
                        -0.15, -0.15, 0.0,
                        0.15, -0.15, 0.0,
                        0.15, 0.15, 0.0
                    ]);
                    break;

                case 'cube':
                    // ç«‹æ–¹ä½“ (ç®€åŒ–ä¸ºä¸¤ä¸ªé¢)
                    vertices = new Float32Array([
                        // å‰é¢
                        -0.1, 0.1, 0.1,
                        -0.1, -0.1, 0.1,
                        0.1, -0.1, 0.1,
                        0.1, 0.1, 0.1,
                        // ä¸Šé¢
                        -0.1, 0.1, -0.1,
                        -0.1, 0.1, 0.1,
                        0.1, 0.1, 0.1,
                        0.1, 0.1, -0.1
                    ]);
                    break;

                case 'circle':
                    // åœ†å½¢
                    vertices = [];
                    const radius = 0.15;
                    for (let i = 0; i < circleSides; i++) {
                        const angle = (i / circleSides) * 2 * Math.PI;
                        vertices.push(
                            Math.cos(angle) * radius,
                            Math.sin(angle) * radius,
                            0.0
                        );
                    }
                    vertices = new Float32Array(vertices);
                    break;
            }

            // è®¾ç½®é¢œè‰²æ•°æ®
            colors = [];
            for (let i = 0; i < vertices.length / 3; i++) {
                colors.push(...obj.color);
            }
            colors = new Float32Array(colors);

            // è®¾ç½®é¡¶ç‚¹ç¼“å†²åŒº
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);

            // è®¾ç½®é¢œè‰²ç¼“å†²åŒº
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
            gl.vertexAttribPointer(vColor, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vColor);

            // ç»˜åˆ¶å›¾å½¢
            if (obj.type === 'circle') {
                gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length / 3);
            } else if (obj.type === 'cube') {
                // ç»˜åˆ¶å‰é¢
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
                // ç»˜åˆ¶ä¸Šé¢
                gl.drawArrays(gl.TRIANGLE_FAN, 4, 4);
            } else {
                gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length / 3);
            }

            // æ¸…ç†ç¼“å†²åŒº
            gl.deleteBuffer(positionBuffer);
            gl.deleteBuffer(colorBuffer);
        }

        // ç®€åŒ–ç‰ˆçŸ©é˜µåº“ (å®é™…é¡¹ç›®ä¸­åº”ä½¿ç”¨å®Œæ•´çš„gl-matrixåº“)
        const mat4 = {
            create: function() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            },

            ortho: function(out, left, right, bottom, top, near, far) {
                const lr = 1 / (left - right);
                const bt = 1 / (bottom - top);
                const nf = 1 / (near - far);

                out[0] = -2 * lr;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = -2 * bt;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = 2 * nf;
                out[11] = 0;
                out[12] = (left + right) * lr;
                out[13] = (top + bottom) * bt;
                out[14] = (far + near) * nf;
                out[15] = 1;

                return out;
            },

            translate: function(out, a, v) {
                const x = v[0], y = v[1], z = v[2];

                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];

                return out;
            },

            rotateZ: function(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0];
                const a01 = a[1];
                const a02 = a[2];
                const a03 = a[3];
                const a10 = a[4];
                const a11 = a[5];
                const a12 = a[6];
                const a13 = a[7];

                out[0] = a00 * c + a10 * s;
                out[1] = a01 * c + a11 * s;
                out[2] = a02 * c + a12 * s;
                out[3] = a03 * c + a13 * s;
                out[4] = a10 * c - a00 * s;
                out[5] = a11 * c - a01 * s;
                out[6] = a12 * c - a02 * s;
                out[7] = a13 * c - a03 * s;

                return out;
            },

            rotate: function(out, a, rad, axis) {
                let x = axis[0], y = axis[1], z = axis[2];
                let len = Math.sqrt(x * x + y * y + z * z);

                if (len < 0.000001) { return null; }

                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;

                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;

                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];

                const b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s;
                const b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s;
                const b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;

                out[0] = a00 * b00 + a10 * b01 + a20 * b02;
                out[1] = a01 * b00 + a11 * b01 + a21 * b02;
                out[2] = a02 * b00 + a12 * b01 + a22 * b02;
                out[3] = a03 * b00 + a13 * b01 + a23 * b02;
                out[4] = a00 * b10 + a10 * b11 + a20 * b12;
                out[5] = a01 * b10 + a11 * b11 + a21 * b12;
                out[6] = a02 * b10 + a12 * b11 + a22 * b12;
                out[7] = a03 * b10 + a13 * b11 + a23 * b12;
                out[8] = a00 * b20 + a10 * b21 + a20 * b22;
                out[9] = a01 * b20 + a11 * b21 + a21 * b22;
                out[10] = a02 * b20 + a12 * b21 + a22 * b22;
                out[11] = a03 * b20 + a13 * b21 + a23 * b22;

                return out;
            },

            scale: function(out, a, v) {
                const x = v[0], y = v[1], z = v[2];

                out[0] = a[0] * x;
                out[1] = a[1] * x;
                out[2] = a[2] * x;
                out[3] = a[3] * x;
                out[4] = a[4] * y;
                out[5] = a[5] * y;
                out[6] = a[6] * y;
                out[7] = a[7] * y;
                out[8] = a[8] * z;
                out[9] = a[9] * z;
                out[10] = a[10] * z;
                out[11] = a[11] * z;

                return out;
            }
        };
    </script>
</body>
</html>